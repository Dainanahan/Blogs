---
title: "Journey to the Center of DrugBank XML"
author: "Mohammed Ali, Ali Ezzat"
date: "December 31, 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(data.tree)
```

## Objective
We will try to take a journey together to explore the wonders of *DrugBank* xml database. How the drugs information structured in different ways inside it and how we can retrive these information using **R**. So our purpose is to show how to parse the database and not to be overwhelmed with the domain information. Let us begin.

## What is DrugBank database
The DrugBank database is a comprehensive, freely accessible, online database containing information on drugs and drug targets.As both a bioinformatics and a cheminformatics resource, DrugBank combines detailed drug (i.e. chemical, pharmacological and pharmaceutical) data with comprehensive drug target (i.e. sequence, structure, and pathway) information [Wikipedia](https://en.wikipedia.org/wiki/DrugBank) and it is in *XML* format.


## Drug Node (Do you remember your children names)
Each drug in the database is represented by `drug` node which contains beside its associated attributes many children which differ in name, functionality and more importantly to us *structure*. Let us take a peak:

```{r drug_sructure, echo=FALSE,  fig.width=12}
drug <- Node$new("Drug")
drug_attrs <- drug$AddChild("Attributes")
drug_attrs$AddChild("Type")
drug_attrs$AddChild("Created")
drug_attrs$AddChild("Updated")

drug_fields <- drug$AddChild("Children")
drug_fields$AddChild("Drugbank Id(s)")
drug_fields$AddChild("Name")
drug_fields$AddChild("description")
drug_fields$AddChild("Groups")
drug_fields$AddChild("References")
drug_fields$AddChild("synonyms")
drug_fields$AddChild("products")
drug_fields$AddChild("mixtures")
drug_fields$AddChild("categories")
drug_fields$AddChild("Many others ...")

# plotting
SetGraphStyle(drug, rankdir = "TB")
SetEdgeStyle(drug, arrowhead = "vee", color = "grey35", penwidth = 2)
SetNodeStyle(drug, style = "filled,rounded", shape = "box", fillcolor = "GreenYellow", 
            fontname = "helvetica", tooltip = GetDefaultTooltip, fontcolor = "Firebrick")
SetNodeStyle(drug$Attributes, fillcolor = "LightBlue", penwidth = "5px")
plot(drug)
```

Wow that is a lot of children that different in format, size (grand children) beside each drug attributes too and are written in following xml format.
```{r drug_xml, eval=FALSE, highlight=TRUE}
<drug type="biotech" created="2005-06-13" updated="2018-07-02">
  <drugbank-id primary="true">DB00001</drugbank-id>
  <drugbank-id>BTD00024</drugbank-id>
  <drugbank-id>BIOD00024</drugbank-id>
  <name>Lepirudin</name>
  <description>Lepirudin is identical to natural hirudin except for substitution of leucine for isoleucine    at the N-terminal end of the molecule and the absence of a sulfate group on the tyrosine at position 63.    It is produced via yeast cells. Bayer ceased the production of lepirudin (Refludan) effective May 31,       2012.</description>
  <cas-number>138068-37-8</cas-number>
  <unii>Y43GF64R34</unii>
  <state>liquid</state>
  <groups>
    <group>approved</group>
  </groups>
  <!-- many other children -->
</drug>  
```

We will start by parsing drug nodes then see how to deal with its children.

### drug node parser
Here we created a function that takes an *XML* rescord as an input and will see how we can extract direct children (that has no grand children) and the drug attributes.
We will use `purrr` and `XML` packages as follow:
* `tibble` -> construct a `tibble` structure contains the drug record information.
* `xmlValue` --> Gets the value of given children.
* `xmlGetAttr` --> Gets given xml node given attribute value.

```{r drug_node_parser, eval=FALSE}
# Extract drug df
drug_df <- function(rec) {
  tibble(
     # drug attribues
    type = xmlGetAttr(node = rec, name = "type"),
    created = as.Date(xmlGetAttr(node = rec, name = "created")),
    updated = as.Date(xmlGetAttr(node = rec, name = "updated")),
    # Each drug has 3 keys to be identified with
    # the primary key is the main key and must be exist
    # the other two keys are optional that is why we
    # are checking for them before parsing
    primary_key = xmlValue(rec["drugbank-id"][[1]]),
    secondary_key = ifelse(length(rec["drugbank-id"]) > 1, xmlValue(rec["drugbank-id"][[2]]), NA),
    third_key = ifelse(length(rec["drugbank-id"]) > 2, xmlValue(rec["drugbank-id"][[3]]), NA),
    name = xmlValue(rec[["name"]]),
    description = xmlValue(rec[["description"]]),
    cas_number = xmlValue(rec[["cas-number"]]),
    unii = xmlValue(rec[["unii"]]),
    state = xmlValue(rec[["state"]])
    ## Getting other attributes
  )
}
```


Then to get the values of all drug nodes using the above function we call `map_df` that will return a complete dataframe (tibble) object of given drugs. It takes two parameters:
* `drugbank$children` --> *XML* tree object for drug bank database
* `drug_df` -> the method we created above 

```{r drug_node_all, eval=FALSE}
# '~' is telling map_df that we are sending the function
# a dynamic parameter that is based on its first parameter
drugs <- map_df(drugbank$children, ~drug_df(.x))
```


## One for All
As we have seen so far each drug node (record) in drugbank xml database has many children. Lucky for us, there are a lot of similar nodes (children), structure wise. So, we built that generic parser for them:

```{r one_for_all, eval=FALSE}
drug_sub_df <- function(rec, main_node, seconadary_node = NULL, id = "drugbank-id", byValue = FALSE) {
    parent_key <- NULL
    # Get Children parent if it is not null, which is drug id in most cases
    if (!is.null(id)) {
        parent_key <- xmlValue(rec[id][[1]])
    }
    # The values are listed directly under the grouping node, no array
    if (byValue) {
        df <- map_df(rec[main_node], xmlValue)
    } else {
        # data is grouped in array of values and can be accessed directly via one node name
        if (is.null(seconadary_node) && !is.null(rec[[main_node]])) {
            df <- xmlToDataFrame(rec[[main_node]], stringsAsFactors = FALSE)
        } else {
            # we need to address the child by two names
            df <- xmlToDataFrame(rec[[main_node]][[seconadary_node]], stringsAsFactors = FALSE)
        }

    }

    # Assign the parent key to the resultant data frame, if any
    if (nrow(df) > 0 && !is.null(parent_key)) {
        df$parent_key <- parent_key
    }
    return(df)
}
```

oh, that seems a little complicated. Well not if knew its parameters and how we cann call, so let us explain it bit by bit.

The method takes two mandatory paramaters, that has no default input:
* `rec` -> current xml child to be parsed.
* `main_node` -> node, child, to be parsed.
Here are some examples of just using those two parameters
```{r drug_sub_df_1, eval=FALSE}
drug_groups <- map_df(pkg.env$children, ~drug_sub_df(.x, "groups"))
drug_products <- map_df(pkg.env$children, ~drug_sub_df(.x, "products"))
```

which has the following xml structure
```{r eval=FALSE, highlight=TRUE}
<groups>
  <group>approved</group>
</groups>
.
.
.
.
<products>
    <product>
      <name>Refludan</name>
      <labeller>Bayer</labeller>
      <ndc-id/>
      <ndc-product-code/>
      <!-- other nodes-->
    </product>
</product>  
```

As we notice, the above share the following:

- They are array of groupd nodes.
- Their direct parent is `drug` node.
