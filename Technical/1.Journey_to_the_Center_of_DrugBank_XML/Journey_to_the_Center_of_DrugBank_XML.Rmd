---
title: "Journey to the Center of DrugBank XML"
author: "Mohammed Ali, Ali Ezzat"
date: "December 31, 2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(data.tree)
```

## Objective
We will try to take a journey together to explore the wonders of *DrugBank* xml database. How the drugs information structured in different ways inside it and how we can retrive these information using **R**. So our purpose is to show how to parse the database and not to be overwhelmed with the domain information. Let us begin.

## What is DrugBank database
The DrugBank database is a comprehensive, freely accessible, online database containing information on drugs and drug targets.As both a bioinformatics and a cheminformatics resource, DrugBank combines detailed drug (i.e. chemical, pharmacological and pharmaceutical) data with comprehensive drug target (i.e. sequence, structure, and pathway) information [Wikipedia](https://en.wikipedia.org/wiki/DrugBank) and it is in *XML* format.


## Do you remember your children names
Each drug in the database is represented by `drug` node which contains beside its associated attributes many children which differ in name, functionality and more importantly to us *structure*. Let us take a peak:

```{r drug_sructure, echo=FALSE,  fig.width=12}
drug <- Node$new("Drug")
drug_attrs <- drug$AddChild("Attributes")
drug_attrs$AddChild("Type")
drug_attrs$AddChild("Created")
drug_attrs$AddChild("Updated")

drug_fields <- drug$AddChild("Children")
drug_fields$AddChild("Drugbank Id(s)")
drug_fields$AddChild("Name")
drug_fields$AddChild("description")
drug_fields$AddChild("Groups")
drug_fields$AddChild("References")
drug_fields$AddChild("synonyms")
drug_fields$AddChild("products")
drug_fields$AddChild("mixtures")
drug_fields$AddChild("categories")
drug_fields$AddChild("Many others ...")

# plotting
SetGraphStyle(drug, rankdir = "TB")
SetEdgeStyle(drug, arrowhead = "vee", color = "grey35", penwidth = 2)
SetNodeStyle(drug, style = "filled,rounded", shape = "box", fillcolor = "GreenYellow", 
            fontname = "helvetica", tooltip = GetDefaultTooltip, fontcolor = "Firebrick")
SetNodeStyle(drug$Attributes, fillcolor = "LightBlue", penwidth = "5px")
plot(drug)
```

Wow that is a lot of children that different in format, size (grand children) beside each drug attributes too. 
We will start by parsing drug nodes then see how to deal with its children.

### drug node parser
Here we created a function that takes an *XML* rescord as an input and will see how we can extract direct children (that has no grand children) and the drug attributes.
We will use `purrr` and `XML` packages as follow:
* `tibble` <- construct a `tibble` structure contains the drug record information.
* `xmlValue` <- Gets the value of given children.
* `xmlGetAttr` <- Gets given xml node given attribute value.

```{r drug_node_parser, eval=FALSE}
# Extract drug df
drug_df <- function(rec) {
  tibble(
     # drug attribues
    type = xmlGetAttr(node = rec, name = "type"),
    created = as.Date(xmlGetAttr(node = rec, name = "created")),
    updated = as.Date(xmlGetAttr(node = rec, name = "updated")),
    # Each drug has 3 keys to be identified with
    # the primary key is the main key and must be exist
    # the other two keys are optional that is why we
    # are checking for them before parsing
    primary_key = xmlValue(rec["drugbank-id"][[1]]),
    secondary_key = ifelse(length(rec["drugbank-id"]) > 1, xmlValue(rec["drugbank-id"][[2]]), NA),
    third_key = ifelse(length(rec["drugbank-id"]) > 2, xmlValue(rec["drugbank-id"][[3]]), NA),
    name = xmlValue(rec[["name"]]),
    description = xmlValue(rec[["description"]]),
    cas_number = xmlValue(rec[["cas-number"]]),
    unii = xmlValue(rec[["unii"]]),
    state = xmlValue(rec[["state"]])
    ## Getting other attributes
  )
}
```


Then to get the values of all drug nodes using the above function we call `map_df` that will return a complete dataframe (tibble) object of given drugs. It takes two parameters:
* `drugbank$children` --> *XML* tree object for drug bank database
* `drug_df` -> the method we created above 

```{r drug_node_all, eval=FALSE}
# '~' is telling map_df that we are sending the function
# a dynamic parameter that is based on its first parameter
drugs <- map_df(drugbank$children, ~drug_df(.x))
```


## One for All
As we have seen so far each drug node (record) in drugbank xml database has many children. Lucky for us, there are a lot of similar nodes (children), structure wise. So, we built that generic parser for them:

```{r one_for_all, eval=FALSE}
drug_sub_df <- function(rec, main_node, seconadary_node = NULL, id = "drugbank-id", byValue = FALSE) {
    parent_key <- NULL
    if (!is.null(id)) {
        parent_key <- xmlValue(rec[id][[1]])
    }

    if (byValue) {
        df <- map_df(rec[main_node], xmlValue)
    } else {
        if (is.null(seconadary_node) && !is.null(rec[[main_node]])) {
            df <- xmlToDataFrame(rec[[main_node]], stringsAsFactors = FALSE)
        } else {
            df <- xmlToDataFrame(rec[[main_node]][[seconadary_node]], stringsAsFactors = FALSE)
        }

    }

    if (nrow(df) > 0 && !is.null(parent_key)) {
        df$parent_key <- parent_key
    }
    return(df)
}
```

oh, that seems a little complicated. Well not if knew its parameters and how we cann call, so let us explain it bit by bit.

The method takes two mandatory paramaters, that has no default input:
* `rec` -> current xml child to be parsed.
* `main_node` -> node, child, to be parsed.
Here are some examples of just using those two parameters

## put xml examples too.